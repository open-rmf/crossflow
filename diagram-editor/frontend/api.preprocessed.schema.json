{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$defs": {
    "BufferAccessSchema": {
      "description": "Zip a message together with access to one or more buffers.\n\nThe receiving node must have an input type of `(Message, Keys)`\nwhere `Keys` implements the [`Accessor`][1] trait.\n\n[1]: crate::Accessor\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"fork_clone\",\n    \"ops\": {\n        \"fork_clone\": {\n            \"type\": \"fork_clone\",\n            \"next\": [\"num_output\", \"string_output\"]\n        },\n        \"num_output\": {\n            \"type\": \"node\",\n            \"builder\": \"num_output\",\n            \"next\": \"buffer_access\"\n        },\n        \"string_output\": {\n            \"type\": \"node\",\n            \"builder\": \"string_output\",\n            \"next\": \"string_buffer\"\n        },\n        \"string_buffer\": {\n            \"type\": \"buffer\"\n        },\n        \"buffer_access\": {\n            \"type\": \"buffer_access\",\n            \"buffers\": [\"string_buffer\"],\n            \"next\": \"with_buffer_access\"\n        },\n        \"with_buffer_access\": {\n            \"type\": \"node\",\n            \"builder\": \"with_buffer_access\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "buffers": {
          "$ref": "#/$defs/BufferSelection"
        },
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "$ref": "#/$defs/NextOperation"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "next",
        "buffers"
      ],
      "type": "object"
    },
    "BufferIdentifier": {
      "anyOf": [
        {
          "description": "Identify a buffer by name",
          "type": "string"
        },
        {
          "description": "Identify a buffer by an index value",
          "format": "uint",
          "minimum": 0,
          "type": "integer"
        }
      ]
    },
    "BufferMapLayoutHints": {
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "The buffers in this map and their message types are not necessarily known in advance.",
          "properties": {
            "dynamic": {
              "$ref": "#/$defs/DynamicBufferMapLayoutHints"
            }
          },
          "required": [
            "dynamic"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "The buffer identifiers and their message types are fixed in advance.",
          "properties": {
            "static": {
              "additionalProperties": {
                "$ref": "#/$defs/MessageTypeHint"
              },
              "patternProperties": {
                "^\\d+$": {
                  "$ref": "#/$defs/MessageTypeHint"
                }
              },
              "type": "object"
            }
          },
          "required": [
            "static"
          ],
          "type": "object"
        }
      ]
    },
    "BufferSchema": {
      "description": "Create a [`Buffer`][1] which can be used to store and pull data within\na scope.\n\nBy default the [`BufferSettings`][2] will keep the single last message\npushed to the buffer. You can change that with the optional `settings`\nproperty.\n\nUse the `\"serialize\": true` option to serialize the messages into\n[`JsonMessage`] before they are inserted into the buffer. This\nallows any serializable message type to be pushed into the buffer. If\nleft unspecified, the buffer will store the specific data type that gets\npushed into it. If the buffer inputs are not being serialized, then all\nincoming messages being pushed into the buffer must have the same type.\n\n[1]: crate::Buffer\n[2]: crate::BufferSettings\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"fork_clone\",\n    \"ops\": {\n        \"fork_clone\": {\n            \"type\": \"fork_clone\",\n            \"next\": [\"num_output\", \"string_output\", \"all_num_buffer\", \"serialized_num_buffer\"]\n        },\n        \"num_output\": {\n            \"type\": \"node\",\n            \"builder\": \"num_output\",\n            \"next\": \"buffer_access\"\n        },\n        \"string_output\": {\n            \"type\": \"node\",\n            \"builder\": \"string_output\",\n            \"next\": \"string_buffer\"\n        },\n        \"string_buffer\": {\n            \"type\": \"buffer\",\n            \"settings\": {\n                \"retention\": { \"keep_last\": 10 }\n            }\n        },\n        \"all_num_buffer\": {\n            \"type\": \"buffer\",\n            \"settings\": {\n                \"retention\": \"keep_all\"\n            }\n        },\n        \"serialized_num_buffer\": {\n            \"type\": \"buffer\",\n            \"serialize\": true\n        },\n        \"buffer_access\": {\n            \"type\": \"buffer_access\",\n            \"buffers\": [\"string_buffer\"],\n            \"next\": \"with_buffer_access\"\n        },\n        \"with_buffer_access\": {\n            \"type\": \"node\",\n            \"builder\": \"with_buffer_access\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "serialize": {
          "description": "If true, messages will be serialized before sending into the buffer.",
          "type": "boolean"
        },
        "settings": {
          "$ref": "#/$defs/BufferSettings"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "type": "object"
    },
    "BufferSelection": {
      "anyOf": [
        {
          "additionalProperties": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "object"
        },
        {
          "items": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "array"
        }
      ]
    },
    "BufferSettings": {
      "description": "Settings to describe the behavior of a buffer.",
      "properties": {
        "retention": {
          "$ref": "#/$defs/RetentionPolicy"
        }
      },
      "required": [
        "retention"
      ],
      "type": "object"
    },
    "BuiltinTarget": {
      "oneOf": [
        {
          "const": "terminate",
          "description": "Use the output to terminate the current scope. The value passed into\nthis operation will be the return value of the scope.",
          "type": "string"
        },
        {
          "const": "dispose",
          "description": "Dispose of the output.",
          "type": "string"
        },
        {
          "const": "cancel",
          "description": "When triggered, cancel the current scope. If this is an inner scope of a\nworkflow then the parent scope will see a disposal happen. If this is\nthe root scope of a workflow then the whole workflow will cancel.",
          "type": "string"
        }
      ]
    },
    "ConfigExample": {
      "properties": {
        "config": {
          "description": "The value of the config"
        },
        "description": {
          "description": "A description of what this config is for",
          "type": "string"
        }
      },
      "required": [
        "description",
        "config"
      ],
      "type": "object"
    },
    "DebugSessionMessage": {
      "oneOf": [
        {
          "allOf": [
            {
              "oneOf": [
                {
                  "properties": {
                    "operationStarted": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "operationStarted"
                  ],
                  "type": "object"
                }
              ]
            },
            {
              "properties": {
                "type": {
                  "const": "feedback",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "oneOf": [
                {
                  "properties": {
                    "ok": true
                  },
                  "required": [
                    "ok"
                  ],
                  "type": "object"
                },
                {
                  "properties": {
                    "err": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "err"
                  ],
                  "type": "object"
                }
              ]
            },
            {
              "properties": {
                "type": {
                  "const": "finish",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        }
      ]
    },
    "Diagram": {
      "properties": {
        "default_trace": {
          "$ref": "#/$defs/TraceToggle"
        },
        "description": {
          "description": "Optional text to describe the workflow.",
          "type": "string"
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "input_examples": {
          "description": "Examples of inputs that can be used with this workflow.",
          "items": {
            "$ref": "#/$defs/InputExample"
          },
          "type": "array"
        },
        "on_implicit_error": {
          "anyOf": [
            {
              "$ref": "#/$defs/NextOperation"
            },
            {
              "type": "null"
            }
          ]
        },
        "ops": {
          "additionalProperties": {
            "$ref": "#/$defs/DiagramOperation"
          },
          "description": "Operations that define the workflow",
          "type": "object"
        },
        "start": {
          "$ref": "#/$defs/NextOperation"
        },
        "templates": {
          "additionalProperties": {
            "$ref": "#/$defs/SectionTemplate"
          },
          "default": {},
          "type": "object"
        },
        "version": {
          "description": "Version of the diagram, should always be `0.1.0`.",
          "type": "string"
        }
      },
      "required": [
        "version",
        "start",
        "ops"
      ],
      "type": "object"
    },
    "DiagramElementMetadata": {
      "properties": {
        "messages": {
          "items": {
            "$ref": "#/$defs/MessageMetadata"
          },
          "type": "array"
        },
        "nodes": {
          "additionalProperties": {
            "$ref": "#/$defs/NodeMetadata"
          },
          "type": "object"
        },
        "reverse_message_lookup": {
          "$ref": "#/$defs/ReverseMessageLookup"
        },
        "schemas": {
          "additionalProperties": true,
          "type": "object"
        },
        "sections": {
          "additionalProperties": {
            "$ref": "#/$defs/SectionMetadata"
          },
          "type": "object"
        },
        "trace_supported": {
          "type": "boolean"
        }
      },
      "required": [
        "nodes",
        "sections",
        "messages",
        "schemas",
        "reverse_message_lookup",
        "trace_supported"
      ],
      "type": "object"
    },
    "DiagramOperation": {
      "oneOf": [
        {
          "allOf": [
            {
              "$ref": "#/$defs/NodeSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "node",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/SectionSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "section",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/ScopeSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "scope",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/StreamOutSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "stream_out",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/ForkCloneSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "fork_clone",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/UnzipSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "unzip",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/ForkResultSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "fork_result",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/SplitSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "split",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/JoinSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "join",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/TransformSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "transform",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/BufferSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "buffer",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/BufferAccessSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "buffer_access",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        },
        {
          "allOf": [
            {
              "$ref": "#/$defs/ListenSchema"
            },
            {
              "properties": {
                "type": {
                  "const": "listen",
                  "type": "string"
                }
              },
              "required": [
                "type"
              ],
              "type": "object"
            }
          ]
        }
      ]
    },
    "DynamicBufferMapLayoutHints": {
      "properties": {
        "hint": {
          "anyOf": [
            {
              "$ref": "#/$defs/MessageTypeHint"
            },
            {
              "type": "null"
            }
          ]
        },
        "indices": {
          "description": "The buffer identifiers can include indices.",
          "type": "boolean"
        },
        "names": {
          "description": "The buffer identifiers can include names.",
          "type": "boolean"
        }
      },
      "required": [
        "indices",
        "names"
      ],
      "type": "object"
    },
    "ForkCloneSchema": {
      "description": "If the request is cloneable, clone it into multiple responses that can\neach be sent to a different operation. The `next` property is an array.\n\nThis creates multiple simultaneous branches of execution within the\nworkflow. Usually when you have multiple branches you will either\n* race - connect all branches to `terminate` and the first branch to\n  finish \"wins\" the race and gets to the be output\n* join - connect each branch into a buffer and then use the `join`\n  operation to reunite them\n* collect - TODO(@mxgrey): [add the collect operation](https://github.com/open-rmf/crossflow/issues/59)\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"begin_race\",\n    \"ops\": {\n        \"begin_race\": {\n            \"type\": \"fork_clone\",\n            \"next\": [\n                \"ferrari\",\n                \"mustang\"\n            ]\n        },\n        \"ferrari\": {\n            \"type\": \"node\",\n            \"builder\": \"drive\",\n            \"config\": \"ferrari\",\n            \"next\": { \"builtin\": \"terminate\" }\n        },\n        \"mustang\": {\n            \"type\": \"node\",\n            \"builder\": \"drive\",\n            \"config\": \"mustang\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "items": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "array"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "next"
      ],
      "type": "object"
    },
    "ForkResultSchema": {
      "description": "If the request is a [`Result<T, E>`], send the output message down an\n`ok` branch or down an `err` branch depending on whether the result has\nan [`Ok`] or [`Err`] value. The `ok` branch will receive a `T` while the\n`err` branch will receive an `E`.\n\nOnly one branch will be activated by each input message that enters the\noperation.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"fork_result\",\n    \"ops\": {\n        \"fork_result\": {\n            \"type\": \"fork_result\",\n            \"ok\": { \"builtin\": \"terminate\" },\n            \"err\": { \"builtin\": \"dispose\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "err": {
          "$ref": "#/$defs/NextOperation"
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "ok": {
          "$ref": "#/$defs/NextOperation"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "ok",
        "err"
      ],
      "type": "object"
    },
    "InputExample": {
      "properties": {
        "description": {
          "type": "string"
        },
        "value": true
      },
      "required": [
        "value",
        "description"
      ],
      "type": "object"
    },
    "InputRemapping": {
      "anyOf": [
        {
          "description": "Do a simple 1:1 forwarding of the names listed in the array",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "additionalProperties": {
            "$ref": "#/$defs/NextOperation"
          },
          "description": "Rename an operation inside the section to expose it externally. The key\nof the map is what siblings of the section can connect to, and the value\nof the entry is the identifier of the input inside the section that is\nbeing exposed.\n\nThis allows a section to expose inputs and buffers that are provided\nby inner sections.",
          "type": "object"
        }
      ]
    },
    "JoinSchema": {
      "description": "Wait for exactly one item to be available in each buffer listed in\n`buffers`, then join each of those items into a single output message\nthat gets sent to `next`.\n\nIf the `next` operation is not a `node` type (e.g. `fork_clone`) then\nyou must specify a `target_node` so that the diagram knows what data\nstructure to join the values into.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"begin_measuring\",\n    \"ops\": {\n        \"begin_measuring\": {\n            \"type\": \"fork_clone\",\n            \"next\": [\"localize\", \"imu\"]\n        },\n        \"localize\": {\n            \"type\": \"node\",\n            \"builder\": \"localize\",\n            \"next\": \"estimated_position\"\n        },\n        \"imu\": {\n            \"type\": \"node\",\n            \"builder\": \"imu\",\n            \"config\": \"velocity\",\n            \"next\": \"estimated_velocity\"\n        },\n        \"estimated_position\": { \"type\": \"buffer\" },\n        \"estimated_velocity\": { \"type\": \"buffer\" },\n        \"gather_state\": {\n            \"type\": \"join\",\n            \"buffers\": {\n                \"position\": \"estimate_position\",\n                \"velocity\": \"estimate_velocity\"\n            },\n            \"next\": \"report_state\"\n        },\n        \"report_state\": {\n            \"type\": \"node\",\n            \"builder\": \"publish_state\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "buffers": {
          "$ref": "#/$defs/BufferSelection"
        },
        "clone": {
          "description": "List of the keys in the `buffers` dictionary whose value should be cloned\ninstead of removed from the buffer (pulled) when the join occurs. Cloning\nthe value will leave the buffer unchanged after the join operation takes\nplace.",
          "items": {
            "$ref": "#/$defs/BufferIdentifier"
          },
          "type": "array"
        },
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "$ref": "#/$defs/NextOperation"
        },
        "serialize": {
          "description": "Whether or not to automatically serialize the inputs into a single JsonMessage.\nThis will only work if all input types are serializable, otherwise you will\nget a [`DiagramError`][super::DiagramError].",
          "type": "boolean"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "next",
        "buffers"
      ],
      "type": "object"
    },
    "ListenSchema": {
      "description": "Listen on a buffer.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"num_output\",\n    \"ops\": {\n        \"buffer\": {\n            \"type\": \"buffer\"\n        },\n        \"num_output\": {\n            \"type\": \"node\",\n            \"builder\": \"num_output\",\n            \"next\": \"buffer\"\n        },\n        \"listen\": {\n            \"type\": \"listen\",\n            \"buffers\": [\"buffer\"],\n            \"next\": \"listen_buffer\"\n        },\n        \"listen_buffer\": {\n            \"type\": \"node\",\n            \"builder\": \"listen_buffer\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())",
      "properties": {
        "buffers": {
          "$ref": "#/$defs/BufferSelection"
        },
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "$ref": "#/$defs/NextOperation"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "next",
        "buffers"
      ],
      "type": "object"
    },
    "MessageMetadata": {
      "properties": {
        "operations": {
          "anyOf": [
            {
              "$ref": "#/$defs/MessageOperationsMetadata"
            },
            {
              "type": "null"
            }
          ]
        },
        "schema": {
          "anyOf": [
            {
              "$ref": "#/$defs/Schema"
            },
            {
              "type": "null"
            }
          ]
        },
        "type_name": {
          "type": "string"
        }
      },
      "required": [
        "type_name"
      ],
      "type": "object"
    },
    "MessageOperationsMetadata": {
      "properties": {
        "deserialize": {
          "type": [
            "object",
            "null"
          ]
        },
        "fork_clone": {
          "type": [
            "object",
            "null"
          ]
        },
        "fork_result": {
          "items": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "maxItems": 2,
          "minItems": 2,
          "type": [
            "array",
            "null"
          ]
        },
        "from": {
          "items": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "type": "array",
          "uniqueItems": true
        },
        "into": {
          "items": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "type": "array",
          "uniqueItems": true
        },
        "join": {
          "anyOf": [
            {
              "$ref": "#/$defs/BufferMapLayoutHints"
            },
            {
              "type": "null"
            }
          ]
        },
        "serialize": {
          "type": [
            "object",
            "null"
          ]
        },
        "split": {
          "type": [
            "object",
            "null"
          ]
        },
        "try_from": {
          "items": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "type": "array",
          "uniqueItems": true
        },
        "try_into": {
          "items": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "type": "array",
          "uniqueItems": true
        },
        "unzip": {
          "items": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "type": [
            "array",
            "null"
          ]
        }
      },
      "required": [
        "into",
        "try_into",
        "from",
        "try_from"
      ],
      "type": "object"
    },
    "MessageTypeHint": {
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "An accessor is asking specifically for this type T via `BufferKey<T>`",
          "properties": {
            "exact": {
              "format": "uint",
              "minimum": 0,
              "type": "integer"
            }
          },
          "required": [
            "exact"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "An accessor is using a generalized buffer, e.g. JsonBuffer or AnyBuffer,\nwhich can be represented by this type, but an exact type should be used\nif any other accessor has one.",
          "properties": {
            "fallback": {
              "format": "uint",
              "minimum": 0,
              "type": "integer"
            }
          },
          "required": [
            "fallback"
          ],
          "type": "object"
        }
      ]
    },
    "NamespacedOperation": {
      "additionalProperties": {
        "type": "string"
      },
      "description": "Refer to an operation inside of a namespace, e.g. { \"<namespace>\": \"<operation>\"",
      "maxProperties": 1,
      "minProperties": 1,
      "title": "NamespacedOperation",
      "type": "object"
    },
    "NextOperation": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "properties": {
            "builtin": {
              "$ref": "#/$defs/BuiltinTarget"
            }
          },
          "required": [
            "builtin"
          ],
          "type": "object"
        },
        {
          "$ref": "#/$defs/NamespacedOperation"
        }
      ]
    },
    "NodeMetadata": {
      "properties": {
        "config_examples": {
          "items": {
            "$ref": "#/$defs/ConfigExample"
          },
          "type": "array"
        },
        "config_schema": {
          "$ref": "#/$defs/Schema"
        },
        "default_display_text": {
          "description": "If the user does not specify a default display text, the node ID will\nbe used here.",
          "type": "string"
        },
        "description": {
          "type": [
            "string",
            "null"
          ]
        },
        "request": {
          "format": "uint",
          "minimum": 0,
          "type": "integer"
        },
        "response": {
          "format": "uint",
          "minimum": 0,
          "type": "integer"
        },
        "streams": {
          "additionalProperties": {
            "format": "uint",
            "minimum": 0,
            "type": "integer"
          },
          "type": "object"
        }
      },
      "required": [
        "default_display_text",
        "request",
        "response",
        "streams",
        "config_schema",
        "config_examples"
      ],
      "type": "object"
    },
    "NodeSchema": {
      "description": "Create an operation that that takes an input message and produces an\noutput message.\n\nThe behavior is determined by the choice of node `builder` and\noptionally the `config` that you provide. Each type of node builder has\nits own schema for the config.\n\nThe output message will be sent to the operation specified by `next`.\n\nTODO(@mxgrey): [Support stream outputs](https://github.com/open-rmf/crossflow/issues/43)\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"cutting_board\",\n    \"ops\": {\n        \"cutting_board\": {\n            \"type\": \"node\",\n            \"builder\": \"chop\",\n            \"config\": \"diced\",\n            \"next\": \"bowl\"\n        },\n        \"bowl\": {\n            \"type\": \"node\",\n            \"builder\": \"stir\",\n            \"next\": \"oven\"\n        },\n        \"oven\": {\n            \"type\": \"node\",\n            \"builder\": \"bake\",\n            \"config\": {\n                \"temperature\": 200,\n                \"duration\": 120\n            },\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())",
      "properties": {
        "builder": {
          "type": "string"
        },
        "config": true,
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "$ref": "#/$defs/NextOperation"
        },
        "stream_out": {
          "additionalProperties": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "object"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "builder",
        "next"
      ],
      "type": "object"
    },
    "PostRunRequest": {
      "properties": {
        "diagram": {
          "$ref": "#/$defs/Diagram"
        },
        "request": true
      },
      "required": [
        "diagram",
        "request"
      ],
      "type": "object"
    },
    "RetentionPolicy": {
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Keep the last N items that were stored into the buffer. Once the limit\nis reached, the oldest item will be removed any time a new item arrives.",
          "properties": {
            "keep_last": {
              "format": "uint",
              "minimum": 0,
              "type": "integer"
            }
          },
          "required": [
            "keep_last"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Keep the first N items that are stored into the buffer. Once the limit\nis reached, any new item that arrives will be discarded.",
          "properties": {
            "keep_first": {
              "format": "uint",
              "minimum": 0,
              "type": "integer"
            }
          },
          "required": [
            "keep_first"
          ],
          "type": "object"
        },
        {
          "const": "keep_all",
          "description": "Do not limit how many items can be stored in the buffer.",
          "type": "string"
        }
      ]
    },
    "ReverseMessageLookup": {
      "properties": {
        "json_message": {
          "description": "The index where the [`JsonMessage`] type is registered.",
          "format": "uint",
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        },
        "result": {
          "description": "Map from [T, E] output registrations to Result<T, E> registration.",
          "items": {
            "maxItems": 2,
            "minItems": 2,
            "prefixItems": [
              {
                "items": {
                  "format": "uint",
                  "minimum": 0,
                  "type": "integer"
                },
                "maxItems": 2,
                "minItems": 2,
                "type": "array"
              },
              {
                "format": "uint",
                "minimum": 0,
                "type": "integer"
              }
            ],
            "type": "array"
          },
          "type": "array"
        },
        "split": {
          "description": "Map from the message type of the item that comes out of a split to all\nmessage types that can be split into it.",
          "items": {
            "maxItems": 2,
            "minItems": 2,
            "prefixItems": [
              {
                "format": "uint",
                "minimum": 0,
                "type": "integer"
              },
              {
                "items": {
                  "format": "uint",
                  "minimum": 0,
                  "type": "integer"
                },
                "type": "array"
              }
            ],
            "type": "array"
          },
          "type": "array"
        },
        "unzip": {
          "description": "Map from the unzipped types to the original zipped type.",
          "items": {
            "maxItems": 2,
            "minItems": 2,
            "prefixItems": [
              {
                "items": {
                  "format": "uint",
                  "minimum": 0,
                  "type": "integer"
                },
                "type": "array"
              },
              {
                "format": "uint",
                "minimum": 0,
                "type": "integer"
              }
            ],
            "type": "array"
          },
          "type": "array"
        }
      },
      "required": [
        "result",
        "unzip",
        "split"
      ],
      "type": "object"
    },
    "Schema": {
      "type": [
        "object",
        "boolean"
      ]
    },
    "ScopeSchema": {
      "description": "Create a scope which will function like its own encapsulated workflow\nwithin the paren workflow. Each message that enters a scope will trigger\na new independent session for that scope to begin running with the incoming\nmessage itself being the input message of the scope. When multiple sessions\nfor the same scope are running, they cannot see or interfere with each other.\n\nOnce a session terminates, the scope will send the terminating message as\nits output. Scopes can use the `stream_out` operation to stream messages out\nto the parent workflow while running.\n\nScopes have two common uses:\n* isolate - Prevent simultaneous runs of the same workflow components\n  (especially buffers) from interfering with each other.\n* race - Run multiple branches simultaneously inside the scope and race\n  them against each ohter. The first branch that reaches the scope's\n  terminate operation \"wins\" the race, and only its output will continue\n  on in the parent workflow. All other branches will be disposed.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"approach_door\",\n    \"ops\": {\n        \"approach_door\": {\n            \"type\": \"scope\",\n            \"start\": \"begin\",\n            \"ops\": {\n                \"begin\": {\n                    \"type\": \"fork_clone\",\n                    \"next\": [\n                        \"move_to_door\",\n                        \"detect_door_proximity\"\n                    ]\n                },\n                \"move_to_door\": {\n                    \"type\": \"node\",\n                    \"builder\": \"move\",\n                    \"config\": {\n                        \"place\": \"L1_north_lobby_outside\"\n                    },\n                    \"next\": { \"builtin\" : \"terminate\" }\n                },\n                \"detect_proximity\": {\n                    \"type\": \"node\",\n                    \"builder\": \"detect_proximity\",\n                    \"config\": {\n                        \"type\": \"door\",\n                        \"name\": \"L1_north_lobby\"\n                    },\n                    \"next\": { \"builtin\" : \"terminate\" }\n                }\n            },\n            \"next\": { \"builtin\" : \"try_open_door\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "$ref": "#/$defs/NextOperation"
        },
        "on_implicit_error": {
          "anyOf": [
            {
              "$ref": "#/$defs/NextOperation"
            },
            {
              "type": "null"
            }
          ]
        },
        "ops": {
          "additionalProperties": {
            "$ref": "#/$defs/DiagramOperation"
          },
          "description": "Operations that exist inside this scope.",
          "type": "object"
        },
        "settings": {
          "$ref": "#/$defs/ScopeSettings"
        },
        "start": {
          "$ref": "#/$defs/NextOperation"
        },
        "stream_out": {
          "additionalProperties": {
            "$ref": "#/$defs/NextOperation"
          },
          "default": {},
          "description": "Where to connect streams that are coming out of this scope.",
          "type": "object"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "start",
        "ops",
        "next"
      ],
      "type": "object"
    },
    "ScopeSettings": {
      "description": "Settings which determine how the top-level scope of the workflow behaves.",
      "properties": {
        "uninterruptible": {
          "description": "Should we prevent the scope from being interrupted (e.g. cancelled)?\nFalse by default, meaning by default scopes can be cancelled or\ninterrupted.",
          "type": "boolean"
        }
      },
      "required": [
        "uninterruptible"
      ],
      "type": "object"
    },
    "SectionBuffer": {
      "properties": {
        "message_type": {
          "format": "uint",
          "minimum": 0,
          "type": [
            "integer",
            "null"
          ]
        }
      },
      "type": "object"
    },
    "SectionInput": {
      "properties": {
        "message_type": {
          "format": "uint",
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "message_type"
      ],
      "type": "object"
    },
    "SectionInterface": {
      "properties": {
        "buffers": {
          "additionalProperties": {
            "$ref": "#/$defs/SectionBuffer"
          },
          "type": "object"
        },
        "inputs": {
          "additionalProperties": {
            "$ref": "#/$defs/SectionInput"
          },
          "type": "object"
        },
        "outputs": {
          "additionalProperties": {
            "$ref": "#/$defs/SectionOutput"
          },
          "type": "object"
        }
      },
      "required": [
        "inputs",
        "outputs",
        "buffers"
      ],
      "type": "object"
    },
    "SectionMetadata": {
      "properties": {
        "config_examples": {
          "items": {
            "$ref": "#/$defs/ConfigExample"
          },
          "type": "array"
        },
        "config_schema": {
          "$ref": "#/$defs/Schema"
        },
        "default_display_text": {
          "type": "string"
        },
        "description": {
          "type": [
            "string",
            "null"
          ]
        },
        "interface": {
          "$ref": "#/$defs/SectionInterface"
        }
      },
      "required": [
        "default_display_text",
        "interface",
        "config_schema",
        "config_examples"
      ],
      "type": "object"
    },
    "SectionOutput": {
      "properties": {
        "message_type": {
          "format": "uint",
          "minimum": 0,
          "type": "integer"
        }
      },
      "required": [
        "message_type"
      ],
      "type": "object"
    },
    "SectionSchema": {
      "allOf": [
        {
          "oneOf": [
            {
              "properties": {
                "builder": {
                  "type": "string"
                }
              },
              "required": [
                "builder"
              ],
              "type": "object"
            },
            {
              "properties": {
                "template": {
                  "type": "string"
                }
              },
              "required": [
                "template"
              ],
              "type": "object"
            }
          ]
        },
        {
          "description": "Connect the request to a registered section.\n\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"section_op\",\n    \"ops\": {\n        \"section_op\": {\n            \"type\": \"section\",\n            \"builder\": \"my_section_builder\",\n            \"connect\": {\n                \"my_section_output\": { \"builtin\": \"terminate\" }\n            }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```\n\nCustom sections can also be created via templates\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"templates\": {\n        \"my_template\": {\n            \"inputs\": [\"section_input\"],\n            \"outputs\": [\"section_output\"],\n            \"buffers\": [],\n            \"ops\": {\n                \"section_input\": {\n                    \"type\": \"node\",\n                    \"builder\": \"my_node\",\n                    \"next\": \"section_output\"\n                }\n            }\n        }\n    },\n    \"start\": \"section_op\",\n    \"ops\": {\n        \"section_op\": {\n            \"type\": \"section\",\n            \"template\": \"my_template\",\n            \"connect\": {\n                \"section_output\": { \"builtin\": \"terminate\" }\n            }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
          "properties": {
            "config": {
              "default": null
            },
            "connect": {
              "additionalProperties": {
                "$ref": "#/$defs/NextOperation"
              },
              "default": {},
              "type": "object"
            },
            "display_text": {
              "description": "Override for text that should be displayed for an operation within an\neditor.",
              "type": [
                "string",
                "null"
              ]
            },
            "extensions": {
              "additionalProperties": true,
              "default": {},
              "description": "Settings for each extension.",
              "type": "object"
            },
            "trace": {
              "anyOf": [
                {
                  "$ref": "#/$defs/TraceToggle"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "type": "object"
        }
      ]
    },
    "SectionTemplate": {
      "properties": {
        "buffers": {
          "$ref": "#/$defs/InputRemapping"
        },
        "inputs": {
          "$ref": "#/$defs/InputRemapping"
        },
        "ops": {
          "additionalProperties": {
            "$ref": "#/$defs/DiagramOperation"
          },
          "description": "Operations that define the behavior of the section.",
          "type": "object"
        },
        "outputs": {
          "default": [],
          "description": "These are the outputs that the section is exposing so you can connect\nthem into siblings of the section.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "ops"
      ],
      "type": "object"
    },
    "SplitSchema": {
      "description": "If the input message is a list-like or map-like object, split it into\nmultiple output messages.\n\nNote that the type of output message from the split depends on how the\ninput message implements the [`Splittable`][1] trait. In many cases this\nwill be a tuple of `(key, value)`.\n\nThere are three ways to specify where the split output messages should\ngo, and all can be used at the same time:\n* `sequential` - For array-like collections, send the \"first\" element of\n  the collection to the first operation listed in the `sequential` array.\n  The \"second\" element of the collection goes to the second operation\n  listed in the `sequential` array. And so on for all elements in the\n  collection. If one of the elements in the collection is mentioned in\n  the `keyed` set, then the sequence will pass over it as if the element\n  does not exist at all.\n* `keyed` - For map-like collections, send the split element associated\n  with the specified key to its associated output.\n* `remaining` - Any elements that are were not captured by `sequential`\n  or by `keyed` will be sent to this.\n\n[1]: crate::Splittable\n\n# Examples\n\nSuppose I am an animal rescuer sorting through a new collection of\nanimals that need recuing. My home has space for three exotic animals\nplus any number of dogs and cats.\n\nI have a custom `SpeciesCollection` data structure that implements\n[`Splittable`][1] by allowing you to key on the type of animal.\n\nIn the workflow below, we send all cats and dogs to `home`, and we also\nsend the first three non-dog and non-cat species to `home`. All\nremaining animals go to the zoo.\n\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"select_animals\",\n    \"ops\": {\n        \"select_animals\": {\n            \"type\": \"split\",\n            \"sequential\": [\n                \"home\",\n                \"home\",\n                \"home\"\n            ],\n            \"keyed\": {\n                \"cat\": \"home\",\n                \"dog\": \"home\"\n            },\n            \"remaining\": \"zoo\"\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```\n\nIf we input `[\"frog\", \"cat\", \"bear\", \"beaver\", \"dog\", \"rabbit\", \"dog\", \"monkey\"]`\nthen `frog`, `bear`, and `beaver` will be sent to `home` since those are\nthe first three animals that are not `dog` or `cat`, and we will also\nsend one `cat` and two `dog` home. `rabbit` and `monkey` will be sent to the zoo.",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "keyed": {
          "additionalProperties": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "object"
        },
        "remaining": {
          "anyOf": [
            {
              "$ref": "#/$defs/NextOperation"
            },
            {
              "type": "null"
            }
          ]
        },
        "sequential": {
          "items": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "array"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "type": "object"
    },
    "StreamOutSchema": {
      "description": "Declare a stream output for the current scope. Outputs that you connect\nto this operation will be streamed out of the scope that this operation\nis declared in.\n\nFor the root-level scope, make sure you use a stream pack that is\ncompatible with all stream out operations that you declare, otherwise\nyou may get a connection error at runtime.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"plan\",\n    \"ops\": {\n        \"progress_stream\": {\n            \"type\": \"stream_out\",\n            \"name\": \"progress\"\n        },\n        \"plan\": {\n            \"type\": \"node\",\n            \"builder\": \"planner\",\n            \"next\": \"drive\",\n            \"stream_out\" : {\n                \"progress\": \"progress_stream\"\n            }\n        },\n        \"drive\": {\n            \"type\": \"node\",\n            \"builder\": \"navigation\",\n            \"next\": { \"builtin\": \"terminate\" },\n            \"stream_out\": {\n                \"progress\": \"progress_stream\"\n            }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "name": {
          "description": "The name of the stream exiting the workflow or scope.",
          "type": "string"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "TraceToggle": {
      "oneOf": [
        {
          "const": "off",
          "description": "Do not emit any signal when the operation is activated.",
          "type": "string"
        },
        {
          "const": "on",
          "description": "Emit a minimal signal with just the operation information when the\noperation is activated.",
          "type": "string"
        },
        {
          "const": "messages",
          "description": "Emit a signal that includes a serialized copy of the message when the\noperation is activated. This may substantially increase the overhead of\ntriggering operations depending on the size and frequency of the messages,\nso it is recommended only for high-level workflows or for debugging.\n\nIf the message is not serializable then it will simply not be included\nin the event information.",
          "type": "string"
        }
      ]
    },
    "TransformSchema": {
      "description": "If the request is serializable, transform it by running it through a [CEL](https://cel.dev/) program.\nThe context includes a \"request\" variable which contains the input message.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"transform\",\n    \"ops\": {\n        \"transform\": {\n            \"type\": \"transform\",\n            \"cel\": \"request.name\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```\n\nNote that due to how `serde_json` performs serialization, positive integers are always\nserialized as unsigned. In CEL, You can't do an operation between unsigned and signed so\nit is recommended to always perform explicit casts.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"transform\",\n    \"ops\": {\n        \"transform\": {\n            \"type\": \"transform\",\n            \"cel\": \"int(request.score) * 3\",\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```",
      "properties": {
        "cel": {
          "type": "string"
        },
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "$ref": "#/$defs/NextOperation"
        },
        "on_error": {
          "anyOf": [
            {
              "$ref": "#/$defs/NextOperation"
            },
            {
              "type": "null"
            }
          ]
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "cel",
        "next"
      ],
      "type": "object"
    },
    "UnzipSchema": {
      "description": "If the input message is a tuple of (T1, T2, T3, ...), unzip it into\nmultiple output messages of T1, T2, T3, ...\n\nEach output message may have a different type and can be sent to a\ndifferent operation. This creates multiple simultaneous branches of\nexecution within the workflow. See [`DiagramOperation::ForkClone`] for\nmore information on parallel branches.\n\n# Examples\n```\n# crossflow::Diagram::from_json_str(r#\"\n{\n    \"version\": \"0.1.0\",\n    \"start\": \"name_phone_address\",\n    \"ops\": {\n        \"name_phone_address\": {\n            \"type\": \"unzip\",\n            \"next\": [\n                \"process_name\",\n                \"process_phone_number\",\n                \"process_address\"\n            ]\n        },\n        \"process_name\": {\n            \"type\": \"node\",\n            \"builder\": \"process_name\",\n            \"next\": \"name_processed\"\n        },\n        \"process_phone_number\": {\n            \"type\": \"node\",\n            \"builder\": \"process_phone_number\",\n            \"next\": \"phone_number_processed\"\n        },\n        \"process_address\": {\n            \"type\": \"node\",\n            \"builder\": \"process_address\",\n            \"next\": \"address_processed\"\n        },\n        \"name_processed\": { \"type\": \"buffer\" },\n        \"phone_number_processed\": { \"type\": \"buffer\" },\n        \"address_processed\": { \"type\": \"buffer\" },\n        \"finished\": {\n            \"type\": \"join\",\n            \"buffers\": [\n                \"name_processed\",\n                \"phone_number_processed\",\n                \"address_processed\"\n            ],\n            \"next\": { \"builtin\": \"terminate\" }\n        }\n    }\n}\n# \"#)?;\n# Ok::<_, serde_json::Error>(())\n```\n\n[`DiagramOperation::ForkClone`]: super::DiagramOperation::ForkClone",
      "properties": {
        "display_text": {
          "description": "Override for text that should be displayed for an operation within an\neditor.",
          "type": [
            "string",
            "null"
          ]
        },
        "extensions": {
          "additionalProperties": true,
          "default": {},
          "description": "Settings for each extension.",
          "type": "object"
        },
        "next": {
          "items": {
            "$ref": "#/$defs/NextOperation"
          },
          "type": "array"
        },
        "trace": {
          "anyOf": [
            {
              "$ref": "#/$defs/TraceToggle"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "required": [
        "next"
      ],
      "type": "object"
    }
  }
}